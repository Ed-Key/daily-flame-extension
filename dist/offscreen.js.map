{"version":3,"file":"offscreen.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://dailyflame/./src/offscreen.ts"],"sourcesContent":["\"use strict\";\n// URL of the hosted authentication handler\nconst AUTH_HANDLER_BASE_URL = 'https://daily-flame.web.app/auth-handler.html';\n// Create iframe for authentication\nlet iframe = null;\nlet isIframeReady = false;\n// Queue for auth requests that arrive before iframe is ready\nconst authRequestQueue = [];\n// Process queued auth requests\nfunction processQueuedRequests() {\n    while (authRequestQueue.length > 0) {\n        const { request, sendResponse } = authRequestQueue.shift();\n        handleAuthRequest(request, sendResponse);\n    }\n}\n// Initialize the authentication iframe with fresh cache busting\nfunction initializeAuthFrame(forceRecreate = false) {\n    // Remove existing iframe if force recreate is requested\n    if (forceRecreate && iframe) {\n        console.log('Offscreen: Removing existing iframe for fresh load');\n        if (iframe.parentNode) {\n            iframe.parentNode.removeChild(iframe);\n        }\n        iframe = null;\n        isIframeReady = false;\n    }\n    if (iframe) {\n        console.log('Offscreen: Iframe already exists');\n        return;\n    }\n    console.log('Offscreen: Creating auth iframe with cache buster');\n    iframe = document.createElement('iframe');\n    // Generate unique session ID for this auth attempt\n    const sessionId = Math.random().toString(36).substring(2) + Date.now();\n    const cacheBuster = Math.random().toString(36).substring(7) + Date.now();\n    const iframeSrc = `${AUTH_HANDLER_BASE_URL}?session=${sessionId}&cb=${cacheBuster}&t=${Date.now()}`;\n    // Set iframe attributes to prevent caching\n    iframe.style.display = 'none';\n    iframe.setAttribute('data-timestamp', Date.now().toString());\n    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-popups allow-forms');\n    iframe.setAttribute('referrerpolicy', 'no-referrer');\n    iframe.setAttribute('importance', 'high');\n    console.log('Offscreen: Iframe URL:', iframeSrc);\n    console.log('Offscreen: Session ID:', sessionId);\n    // Don't set src yet - we'll set it after appending to force fresh load\n    document.body.appendChild(iframe);\n    // Force hard reload by setting src after iframe is in DOM\n    iframe.src = iframeSrc;\n    // Set ready state when iframe loads\n    iframe.onload = () => {\n        console.log('Offscreen: Auth iframe loaded');\n        // Try to force reload if we can access the content\n        try {\n            if (iframe && iframe.contentWindow) {\n                // Force a hard reload of the iframe content\n                iframe.contentWindow.location.reload();\n                console.log('Offscreen: Forced iframe content reload');\n            }\n        }\n        catch (e) {\n            console.log('Offscreen: Could not force reload iframe content');\n        }\n        // Give it a moment for any initialization\n        setTimeout(() => {\n            if (!isIframeReady) {\n                console.log('Offscreen: Setting iframe ready after load');\n                isIframeReady = true;\n                processQueuedRequests();\n            }\n        }, 500);\n    };\n    // Also listen for explicit ready message as backup\n    const readyHandler = (event) => {\n        const origin = new URL(AUTH_HANDLER_BASE_URL).origin;\n        if (event.origin === origin && event.data?.ready) {\n            console.log('Offscreen: Auth iframe signaled ready via postMessage, version:', event.data.version || 'unknown');\n            if (event.data.version) {\n                console.log('Offscreen: Auth handler version confirmed:', event.data.version);\n            }\n            isIframeReady = true;\n            processQueuedRequests();\n        }\n    };\n    window.addEventListener('message', readyHandler);\n    // Listen for BroadcastChannel ready signal\n    try {\n        const readyChannel = new BroadcastChannel('dailyflame-auth');\n        readyChannel.addEventListener('message', (event) => {\n            if (event.data?.ready) {\n                console.log('Offscreen: Auth iframe signaled ready via BroadcastChannel, version:', event.data.version || 'unknown');\n                if (event.data.version) {\n                    console.log('Offscreen: Auth handler version confirmed:', event.data.version);\n                }\n                isIframeReady = true;\n                processQueuedRequests();\n                readyChannel.close();\n            }\n        });\n    }\n    catch (error) {\n        console.log('Offscreen: BroadcastChannel not available for ready signal');\n    }\n    // Force ready state after timeout as final fallback\n    setTimeout(() => {\n        if (!isIframeReady) {\n            console.log('Offscreen: Force setting iframe ready after timeout');\n            isIframeReady = true;\n            processQueuedRequests();\n        }\n    }, 1000);\n    document.body.appendChild(iframe);\n}\n// Initialize iframe when offscreen document loads\ninitializeAuthFrame();\n// Listen for messages from the background script\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    if (request.target !== 'offscreen-auth') {\n        return false;\n    }\n    // If iframe is not ready, queue the request\n    if (!isIframeReady) {\n        console.log('Offscreen: Iframe not ready, queuing auth request');\n        authRequestQueue.push({ request, sendResponse });\n    }\n    else {\n        handleAuthRequest(request, sendResponse);\n    }\n    return true; // Will respond asynchronously\n});\nasync function handleAuthRequest(request, sendResponse) {\n    console.log('Offscreen: Handling auth request:', request.action);\n    // Force recreate iframe for each auth request to ensure fresh code\n    initializeAuthFrame(true);\n    // Wait for iframe to be ready\n    if (!isIframeReady) {\n        console.log('Offscreen: Waiting for iframe to be ready after recreation...');\n        await new Promise(resolve => {\n            const checkReady = setInterval(() => {\n                if (isIframeReady) {\n                    clearInterval(checkReady);\n                    resolve(true);\n                }\n            }, 100);\n            // Timeout after 5 seconds\n            setTimeout(() => {\n                clearInterval(checkReady);\n                resolve(false);\n            }, 5000);\n        });\n    }\n    let attempts = 0;\n    const maxAttempts = 3;\n    let responseReceived = false;\n    let responseHandler = null;\n    let broadcastChannel = null;\n    let broadcastHandler = null;\n    function attemptAuth() {\n        attempts++;\n        console.log(`Offscreen: Auth attempt ${attempts} of ${maxAttempts}`);\n        // Set up BroadcastChannel listener\n        try {\n            broadcastChannel = new BroadcastChannel('dailyflame-auth');\n            broadcastHandler = (event) => {\n                console.log('Offscreen: Received via BroadcastChannel:', event.data);\n                // Only accept messages with expected auth response format\n                if (!event.data || typeof event.data !== 'object' || !('success' in event.data)) {\n                    console.log('Offscreen: Ignoring malformed broadcast message:', event.data);\n                    return;\n                }\n                // Mark response as received\n                responseReceived = true;\n                // Clean up listeners\n                if (broadcastChannel) {\n                    broadcastChannel.removeEventListener('message', broadcastHandler);\n                    broadcastChannel.close();\n                }\n                if (responseHandler) {\n                    window.removeEventListener('message', responseHandler);\n                }\n                console.log('Offscreen: Processing broadcast response:', event.data);\n                sendResponse(event.data);\n            };\n            broadcastChannel.addEventListener('message', broadcastHandler);\n        }\n        catch (error) {\n            console.warn('Offscreen: BroadcastChannel not available:', error);\n        }\n        // Set up message listener for the response\n        responseHandler = (event) => {\n            if (event.origin !== new URL(AUTH_HANDLER_BASE_URL).origin) {\n                return;\n            }\n            // Filter out Google's internal iframe messages\n            if (typeof event.data === 'string' && event.data.startsWith('!_')) {\n                console.log('Offscreen: Ignoring Google internal message');\n                return;\n            }\n            // Only accept messages with expected auth response format\n            if (!event.data || typeof event.data !== 'object' || !('success' in event.data)) {\n                console.log('Offscreen: Ignoring malformed message:', event.data);\n                return;\n            }\n            // Mark response as received\n            responseReceived = true;\n            // Clean up listeners\n            window.removeEventListener('message', responseHandler);\n            if (broadcastChannel) {\n                broadcastChannel.removeEventListener('message', broadcastHandler);\n                broadcastChannel.close();\n            }\n            console.log('Offscreen: Received response from iframe:', event.data);\n            sendResponse(event.data);\n        };\n        window.addEventListener('message', responseHandler);\n        // Send request to iframe\n        if (iframe && iframe.contentWindow) {\n            const message = {\n                action: request.action,\n                email: request.email,\n                password: request.password\n            };\n            console.log('Offscreen: Sending message to iframe:', message);\n            iframe.contentWindow.postMessage(message, new URL(AUTH_HANDLER_BASE_URL).origin);\n            // Set timeout for retry\n            setTimeout(() => {\n                if (!responseReceived) {\n                    // Clean up listeners\n                    if (responseHandler) {\n                        window.removeEventListener('message', responseHandler);\n                    }\n                    if (broadcastChannel && broadcastHandler) {\n                        broadcastChannel.removeEventListener('message', broadcastHandler);\n                        broadcastChannel.close();\n                    }\n                    if (attempts < maxAttempts) {\n                        console.log('Offscreen: No response from iframe, retrying...');\n                        attemptAuth();\n                    }\n                    else {\n                        console.error('Offscreen: Failed to get response from iframe after', maxAttempts, 'attempts');\n                        sendResponse({\n                            success: false,\n                            error: {\n                                code: 'iframe-timeout',\n                                message: 'Authentication iframe not responding'\n                            }\n                        });\n                    }\n                }\n            }, 15000); // 15 second timeout per attempt\n        }\n        else {\n            if (responseHandler) {\n                window.removeEventListener('message', responseHandler);\n            }\n            if (broadcastChannel && broadcastHandler) {\n                broadcastChannel.removeEventListener('message', broadcastHandler);\n                broadcastChannel.close();\n            }\n            sendResponse({\n                success: false,\n                error: {\n                    code: 'iframe-not-found',\n                    message: 'Authentication iframe not initialized'\n                }\n            });\n        }\n    }\n    attemptAuth();\n}\n// Listen for auth state changes from the iframe and forward to background\nwindow.addEventListener('message', (event) => {\n    if (event.origin !== new URL(AUTH_HANDLER_BASE_URL).origin) {\n        return;\n    }\n    // Filter out Google's internal iframe messages\n    if (typeof event.data === 'string' && event.data.startsWith('!_')) {\n        return;\n    }\n    // Handle auth state change notifications\n    if (event.data && typeof event.data === 'object' && event.data.type === 'authStateChanged') {\n        console.log('Offscreen: Forwarding auth state change to background');\n        chrome.runtime.sendMessage({\n            action: 'authStateChanged',\n            user: event.data.user\n        });\n    }\n});\n"],"names":[],"sourceRoot":""}