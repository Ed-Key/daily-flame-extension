{"version":3,"file":"background.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://dailyflame/./src/background/index-simple.ts"],"sourcesContent":["\"use strict\";\n// Simplified background script without Firebase imports\n// Only handles message routing and chrome.identity operations\n// Detect if running on Microsoft Edge\nfunction isEdgeBrowser() {\n    return navigator.userAgent.includes('Edg/');\n}\n// Google Sign-In handler using chrome.identity API\nasync function handleGoogleSignIn() {\n    console.log('Background: Starting Google Sign-In process');\n    // Check if we're on Edge, which doesn't support getAuthToken\n    if (isEdgeBrowser()) {\n        console.log('Background: Detected Microsoft Edge, using launchWebAuthFlow');\n        return handleGoogleSignInWithWebAuthFlow();\n    }\n    return new Promise((resolve, reject) => {\n        // Force account selection by using 'any' account parameter\n        chrome.identity.getAuthToken({\n            interactive: true,\n            account: { id: 'any' } // Force account picker\n        }, async (result) => {\n            if (chrome.runtime.lastError || !result) {\n                console.error('Background: Google Sign-In failed', chrome.runtime.lastError);\n                reject(new Error(chrome.runtime.lastError?.message || 'Failed to get auth token'));\n                return;\n            }\n            // Extract token from result (could be string or object depending on API version)\n            const authToken = typeof result === 'string' ? result : result.token;\n            if (!authToken) {\n                reject(new Error('No auth token received'));\n                return;\n            }\n            console.log('Background: Google Sign-In successful, token received');\n            // Fetch user info from Google API to get profile photo and details\n            try {\n                const userInfoResponse = await fetch(`https://www.googleapis.com/oauth2/v2/userinfo?access_token=${authToken}`);\n                if (!userInfoResponse.ok) {\n                    console.warn('Background: Failed to fetch user info, proceeding with token only');\n                    resolve({ token: authToken, userInfo: null });\n                    return;\n                }\n                const userInfo = await userInfoResponse.json();\n                console.log('Background: User info fetched successfully');\n                resolve({ token: authToken, userInfo });\n            }\n            catch (error) {\n                console.warn('Background: Error fetching user info:', error);\n                resolve({ token: authToken, userInfo: null });\n            }\n        });\n    });\n}\n// Alternative Google Sign-In for Edge using launchWebAuthFlow\nasync function handleGoogleSignInWithWebAuthFlow() {\n    console.log('Background: Using launchWebAuthFlow for Edge compatibility');\n    const manifest = chrome.runtime.getManifest();\n    const clientId = manifest.oauth2?.client_id;\n    if (!clientId) {\n        throw new Error('OAuth2 client ID not found in manifest');\n    }\n    // Generate redirect URI for the extension\n    const redirectUri = chrome.identity.getRedirectURL();\n    console.log('Background: Redirect URI:', redirectUri);\n    // Build the OAuth2 URL\n    const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');\n    authUrl.searchParams.set('client_id', clientId);\n    authUrl.searchParams.set('response_type', 'token');\n    authUrl.searchParams.set('redirect_uri', redirectUri);\n    authUrl.searchParams.set('scope', 'openid email profile');\n    authUrl.searchParams.set('prompt', 'select_account'); // Force account selection\n    return new Promise((resolve, reject) => {\n        chrome.identity.launchWebAuthFlow({\n            url: authUrl.toString(),\n            interactive: true\n        }, async (responseUrl) => {\n            if (chrome.runtime.lastError || !responseUrl) {\n                console.error('Background: Web auth flow failed', chrome.runtime.lastError);\n                reject(new Error(chrome.runtime.lastError?.message || 'Authentication failed'));\n                return;\n            }\n            // Extract access token from the response URL\n            const url = new URL(responseUrl);\n            const params = new URLSearchParams(url.hash.substring(1)); // Remove the # character\n            const accessToken = params.get('access_token');\n            if (!accessToken) {\n                reject(new Error('No access token in response'));\n                return;\n            }\n            console.log('Background: Access token obtained via web auth flow');\n            // Fetch user info\n            try {\n                const userInfoResponse = await fetch(`https://www.googleapis.com/oauth2/v2/userinfo?access_token=${accessToken}`);\n                if (!userInfoResponse.ok) {\n                    console.warn('Background: Failed to fetch user info');\n                    resolve({ token: accessToken, userInfo: null });\n                    return;\n                }\n                const userInfo = await userInfoResponse.json();\n                console.log('Background: User info fetched successfully');\n                resolve({ token: accessToken, userInfo });\n            }\n            catch (error) {\n                console.warn('Background: Error fetching user info:', error);\n                resolve({ token: accessToken, userInfo: null });\n            }\n        });\n    });\n}\n// Clear all cached auth tokens for testing different accounts\nasync function clearAuthTokens() {\n    console.log('Background: Clearing all cached auth tokens');\n    // Edge doesn't support these methods, so just resolve immediately\n    if (isEdgeBrowser()) {\n        console.log('Background: Edge browser detected, no cached tokens to clear');\n        return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n        // First, try to get current token to revoke it\n        chrome.identity.getAuthToken({ interactive: false }, (result) => {\n            const token = typeof result === 'string' ? result : result?.token;\n            if (token) {\n                // Revoke the token first\n                chrome.identity.removeCachedAuthToken({ token }, () => {\n                    console.log('Background: Removed cached token');\n                });\n            }\n            // Then clear all cached tokens\n            chrome.identity.clearAllCachedAuthTokens(() => {\n                if (chrome.runtime.lastError) {\n                    console.error('Background: Error clearing auth tokens', chrome.runtime.lastError);\n                    reject(new Error(chrome.runtime.lastError.message));\n                    return;\n                }\n                console.log('Background: All auth tokens cleared successfully');\n                resolve();\n            });\n        });\n    });\n}\n// Handle messages from content script and other parts of the extension\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    console.log('Background: Received message:', request.action);\n    if (request.action === 'injectVerseApp') {\n        // Inject the verse app script into the current tab\n        if (!sender.tab?.id) {\n            sendResponse({ success: false, error: 'No tab ID found' });\n            return;\n        }\n        chrome.scripting.executeScript({\n            target: { tabId: sender.tab.id },\n            files: ['verse-app.js']\n        }).then(() => {\n            console.log('Background: Verse app injected successfully');\n            sendResponse({ success: true });\n        }).catch(error => {\n            console.error('Background: Failed to inject verse app:', error);\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep message channel open for async response\n    }\n    // Forward verse-related messages to the content script/verse app\n    if (request.action === 'getDailyVerse' ||\n        request.action === 'getVerse' ||\n        request.action === 'getStoredVerses' ||\n        request.action === 'saveVerses') {\n        // Forward the message to the active tab's content script\n        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n            if (tabs[0]?.id) {\n                chrome.tabs.sendMessage(tabs[0].id, request, (response) => {\n                    if (chrome.runtime.lastError) {\n                        sendResponse({ success: false, error: chrome.runtime.lastError.message });\n                    }\n                    else {\n                        sendResponse(response);\n                    }\n                });\n            }\n            else {\n                sendResponse({ success: false, error: 'No active tab found' });\n            }\n        });\n        return true; // Keep message channel open\n    }\n    if (request.action === 'getVerseShownDate') {\n        const today = new Date().toISOString().split(\"T\")[0];\n        chrome.storage.local.get(\"verseShownDate\", ({ verseShownDate }) => {\n            sendResponse({\n                success: true,\n                verseShownDate: verseShownDate,\n                today: today,\n                shouldShow: verseShownDate !== today\n            });\n        });\n        return true; // Keep message channel open for async response\n    }\n    if (request.action === 'setVerseShownDate') {\n        const today = new Date().toISOString().split(\"T\")[0];\n        chrome.storage.local.set({ verseShownDate: today }, () => {\n            console.log('Daily Flame: Verse shown for', today);\n            sendResponse({ success: true });\n        });\n        return true; // Keep message channel open for async response\n    }\n    if (request.action === 'clearStorage') {\n        chrome.storage.local.clear(() => {\n            console.log('Daily Flame: Storage cleared');\n            sendResponse({ success: true });\n        });\n        return true;\n    }\n    if (request.action === 'googleSignIn') {\n        handleGoogleSignIn()\n            .then(result => {\n            sendResponse({\n                success: true,\n                token: result.token,\n                userInfo: result.userInfo\n            });\n        })\n            .catch(error => {\n            console.error('Background: Error with Google sign-in:', error);\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep message channel open for async response\n    }\n    if (request.action === 'clearAuthTokens') {\n        clearAuthTokens()\n            .then(() => {\n            sendResponse({ success: true });\n        })\n            .catch(error => {\n            console.error('Background: Error clearing auth tokens:', error);\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep message channel open for async response\n    }\n});\n// Handle extension icon clicks - always show verse overlay first\nchrome.action.onClicked.addListener((tab) => {\n    if (!tab.id || !tab.url) {\n        console.log('Background: No tab ID or URL available');\n        return;\n    }\n    // For restricted URLs and OAuth pages, open a new tab with a regular website\n    const skipSites = [\n        \"chrome://\",\n        \"chrome-extension://\",\n        \"moz-extension://\",\n        \"extensions\",\n        \"about:\",\n        \"file://\",\n        // OAuth and authentication URLs\n        \"accounts.google.com\",\n        \"oauth2.googleapis.com\",\n        \"auth.firebase.com\",\n        \"identitytoolkit.googleapis.com\",\n        \"securetoken.googleapis.com\",\n        // Microsoft Edge identity redirect\n        \"login.microsoftonline.com\",\n        \"login.live.com\"\n    ];\n    if (skipSites.some(site => tab.url.includes(site))) {\n        console.log('Background: Cannot inject into restricted/auth URL, opening new tab:', tab.url);\n        chrome.tabs.create({ url: 'https://www.google.com' }, (newTab) => {\n            if (newTab.id) {\n                // Wait a moment for the tab to load, then inject verse app\n                setTimeout(() => {\n                    // Clear storage first\n                    chrome.storage.local.remove(['verseShownDate'], () => {\n                        // Then inject the verse app\n                        chrome.scripting.executeScript({\n                            target: { tabId: newTab.id },\n                            files: ['verse-app.js']\n                        }).then(() => {\n                            console.log('Background: Verse app injected in new tab');\n                        }).catch((error) => {\n                            console.error('Background: Error injecting verse app in new tab:', error);\n                        });\n                    });\n                }, 1500);\n            }\n        });\n        return;\n    }\n    try {\n        // First clear the storage to force show\n        chrome.storage.local.remove(['verseShownDate'], () => {\n            // Then inject the verse app directly\n            chrome.scripting.executeScript({\n                target: { tabId: tab.id },\n                files: ['verse-app.js']\n            }).then(() => {\n                console.log('Background: Verse app injected via icon click');\n            }).catch((error) => {\n                console.error('Background: Error injecting verse app:', error);\n            });\n        });\n    }\n    catch (error) {\n        console.error('Background: Failed to execute script on tab:', tab.url, error);\n    }\n});\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('Daily Flame extension installed');\n});\nconsole.log('Background script loaded successfully');\n"],"names":[],"sourceRoot":""}