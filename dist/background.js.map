{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://dailyflame/./src/utils/date-utils.ts","webpack://dailyflame/webpack/bootstrap","webpack://dailyflame/webpack/runtime/define property getters","webpack://dailyflame/webpack/runtime/hasOwnProperty shorthand","webpack://dailyflame/webpack/runtime/make namespace object","webpack://dailyflame/./src/background/index-simple.ts"],"sourcesContent":["/**\n * Date utility functions for DailyFlame\n * Ensures consistent date handling across the application\n */\n/**\n * Get the current date in the user's local timezone as YYYY-MM-DD string\n * This ensures verse changes happen at midnight in the user's timezone,\n * not at midnight UTC\n */\nexport function getLocalDateString(date = new Date()) {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n}\n/**\n * Parse a YYYY-MM-DD string into a Date object in local timezone\n * Useful for comparing dates or calculating date differences\n */\nexport function parseLocalDateString(dateString) {\n    const [year, month, day] = dateString.split('-').map(Number);\n    return new Date(year, month - 1, day);\n}\n/**\n * Get the day of year (1-365/366) for a given date\n * Used for deterministic verse selection based on date\n */\nexport function getDayOfYear(date = new Date()) {\n    const startOfYear = new Date(date.getFullYear(), 0, 0);\n    const diff = date.getTime() - startOfYear.getTime();\n    const oneDay = 1000 * 60 * 60 * 24;\n    return Math.floor(diff / oneDay);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Simplified background script for Daily Flame Chrome Extension\n// Handles message routing and extension functionality\nimport { getLocalDateString } from '../utils/date-utils';\n// Offscreen document management\nconst OFFSCREEN_DOCUMENT_PATH = '/offscreen.html';\n// Track if offscreen document is created\nlet offscreenDocumentCreated = false;\n// Check if offscreen document already exists\nasync function hasOffscreenDocument() {\n    // Check using Chrome API if available (Chrome 114+)\n    if ('getContexts' in chrome.runtime) {\n        try {\n            // @ts-ignore - getContexts is available in newer Chrome versions\n            const contexts = await chrome.runtime.getContexts({\n                contextTypes: ['OFFSCREEN_DOCUMENT']\n            });\n            return contexts.length > 0;\n        }\n        catch (error) {\n            console.log('getContexts not available, falling back to flag');\n        }\n    }\n    // Fallback to flag tracking\n    return offscreenDocumentCreated;\n}\n// Create offscreen document if it doesn't exist\nasync function setupOffscreenDocument() {\n    if (await hasOffscreenDocument()) {\n        console.log('Offscreen document already exists');\n        return;\n    }\n    try {\n        console.log('Creating new offscreen document...');\n        // @ts-ignore - chrome.offscreen is available with offscreen permission\n        await chrome.offscreen.createDocument({\n            url: chrome.runtime.getURL(OFFSCREEN_DOCUMENT_PATH),\n            // @ts-ignore\n            reasons: ['DOM_SCRAPING'],\n            justification: 'Firebase authentication requires DOM access'\n        });\n        offscreenDocumentCreated = true;\n        console.log('Offscreen document created successfully');\n        // Wait a bit for the document to initialize\n        await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    catch (error) {\n        // Handle specific error cases\n        if (error?.message?.includes('Only a single offscreen document may be created')) {\n            console.log('Offscreen document already exists (caught via error)');\n            offscreenDocumentCreated = true;\n            return;\n        }\n        console.error('Error creating offscreen document:', error);\n        throw error;\n    }\n}\n// Close offscreen document\nasync function closeOffscreenDocument() {\n    if (!(await hasOffscreenDocument())) {\n        return;\n    }\n    try {\n        // @ts-ignore\n        await chrome.offscreen.closeDocument();\n        offscreenDocumentCreated = false;\n    }\n    catch (error) {\n        console.error('Error closing offscreen document:', error);\n    }\n}\n// Store auth state\nlet currentUser = null;\n// Helper function to store auth state in Chrome storage\nasync function storeAuthState(user) {\n    if (user) {\n        await chrome.storage.local.set({\n            authUser: {\n                uid: user.uid,\n                email: user.email,\n                displayName: user.displayName,\n                emailVerified: user.emailVerified,\n                photoURL: user.photoURL\n            },\n            authTimestamp: Date.now()\n        });\n        console.log('Background: Auth state stored in Chrome storage');\n    }\n    else {\n        await chrome.storage.local.remove(['authUser', 'authTimestamp']);\n        console.log('Background: Auth state cleared from Chrome storage');\n    }\n}\n// Helper function to retrieve auth state from Chrome storage\nasync function getStoredAuthState() {\n    const result = await chrome.storage.local.get(['authUser', 'authTimestamp']);\n    if (result.authUser && result.authTimestamp) {\n        // Check if auth state is still valid (24 hours)\n        const isExpired = Date.now() - result.authTimestamp > 24 * 60 * 60 * 1000;\n        if (!isExpired) {\n            console.log('Background: Retrieved valid auth state from Chrome storage');\n            return result.authUser;\n        }\n        else {\n            console.log('Background: Stored auth state expired');\n            await chrome.storage.local.remove(['authUser', 'authTimestamp']);\n        }\n    }\n    return null;\n}\n// Handle messages from content script and other parts of the extension\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    console.log('Background: Received message:', request.action);\n    if (request.action === 'injectVerseApp') {\n        // Inject the verse app script into the current tab\n        if (!sender.tab?.id) {\n            sendResponse({ success: false, error: 'No tab ID found' });\n            return;\n        }\n        chrome.scripting.executeScript({\n            target: { tabId: sender.tab.id },\n            files: ['verse-app.js']\n        }).then(() => {\n            console.log('Background: Verse app injected successfully');\n            sendResponse({ success: true });\n        }).catch(error => {\n            console.error('Background: Failed to inject verse app:', error);\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep message channel open for async response\n    }\n    if (request.action === 'getVerseShownDate') {\n        const today = getLocalDateString();\n        chrome.storage.local.get(\"verseShownDate\", ({ verseShownDate }) => {\n            sendResponse({\n                success: true,\n                verseShownDate: verseShownDate,\n                today: today,\n                shouldShow: verseShownDate !== today\n            });\n        });\n        return true; // Keep message channel open for async response\n    }\n    if (request.action === 'setVerseShownDate') {\n        const today = getLocalDateString();\n        chrome.storage.local.set({ verseShownDate: today }, () => {\n            console.log('Daily Flame: Verse shown for', today);\n            sendResponse({ success: true });\n        });\n        return true; // Keep message channel open for async response\n    }\n    if (request.action === 'clearStorage') {\n        chrome.storage.local.clear(() => {\n            console.log('Daily Flame: Storage cleared');\n            sendResponse({ success: true });\n        });\n        return true;\n    }\n    if (request.action === 'openAuthTab') {\n        // Handle opening authentication tab with offscreen document\n        console.log('Background: Opening auth tab with offscreen document');\n        handleAuthAction(request.authAction, request.authData)\n            .then(result => {\n            sendResponse(result);\n        })\n            .catch(error => {\n            console.error('Background: Auth error:', error);\n            const errorMessage = error instanceof Error ? error.message :\n                (typeof error === 'string' ? error : 'Authentication failed');\n            sendResponse({\n                success: false,\n                error: errorMessage\n            });\n        });\n        return true; // Keep message channel open for async response\n    }\n    // Handle auth state changes from offscreen document\n    if (request.action === 'authStateChanged') {\n        currentUser = request.user;\n        console.log('Background: Auth state changed:', currentUser ? 'User signed in' : 'User signed out');\n        // Store auth state in Chrome storage\n        storeAuthState(currentUser).then(() => {\n            // Notify all tabs about auth state change\n            chrome.tabs.query({}, (tabs) => {\n                tabs.forEach(tab => {\n                    if (tab.id) {\n                        chrome.tabs.sendMessage(tab.id, {\n                            action: 'authStateChanged',\n                            user: currentUser\n                        }).catch(() => {\n                            // Ignore errors for tabs that don't have our content script\n                        });\n                    }\n                });\n            });\n        });\n        return false; // No response needed\n    }\n    // Handle direct auth requests\n    if (request.action === 'auth') {\n        // Special handling for getCurrentUser to check stored auth state\n        if (request.authAction === 'getCurrentUser') {\n            getStoredAuthState().then(storedUser => {\n                if (storedUser) {\n                    currentUser = storedUser;\n                    sendResponse({ success: true, user: storedUser });\n                }\n                else {\n                    sendResponse({ success: true, user: null });\n                }\n            }).catch(error => {\n                console.error('Background: Error getting stored auth state:', error);\n                sendResponse({ success: true, user: null });\n            });\n            return true;\n        }\n        // Handle sendVerificationEmail\n        if (request.authAction === 'sendVerificationEmail') {\n            if (!currentUser) {\n                sendResponse({ success: false, error: 'No user signed in' });\n                return true;\n            }\n            handleAuthAction('sendVerificationEmail', request.authData)\n                .then(result => {\n                sendResponse(result);\n            })\n                .catch(error => {\n                console.error('Background: Error sending verification email:', error);\n                sendResponse({\n                    success: false,\n                    error: error.message || 'Failed to send verification email'\n                });\n            });\n            return true;\n        }\n        handleAuthAction(request.authAction, request.authData)\n            .then(result => {\n            // If sign-in was successful, store the user\n            if (result.success && result.user) {\n                currentUser = result.user;\n                storeAuthState(result.user);\n            }\n            // If sign-out was successful, clear the stored auth state\n            if (result.success && request.authAction === 'signOut') {\n                console.log('Background: Clearing auth state after sign-out');\n                currentUser = null;\n                storeAuthState(null).then(() => {\n                    // Notify all tabs about sign-out\n                    chrome.tabs.query({}, (tabs) => {\n                        tabs.forEach(tab => {\n                            if (tab.id) {\n                                chrome.tabs.sendMessage(tab.id, {\n                                    action: 'authStateChanged',\n                                    user: null\n                                }).catch(() => { });\n                            }\n                        });\n                    });\n                });\n            }\n            sendResponse(result);\n        })\n            .catch(error => {\n            console.error('Background: Auth error:', error);\n            const errorMessage = error instanceof Error ? error.message :\n                (typeof error === 'string' ? error : 'Authentication failed');\n            sendResponse({\n                success: false,\n                error: errorMessage\n            });\n        });\n        return true; // Keep message channel open for async response\n    }\n});\n// Handle authentication actions via offscreen document\nasync function handleAuthAction(action, data) {\n    // Force recreate offscreen document for each auth attempt to avoid caching\n    console.log('Background: Recreating offscreen document for fresh auth attempt');\n    try {\n        // Close existing offscreen document if it exists\n        await closeOffscreenDocument();\n        console.log('Background: Closed existing offscreen document');\n        // Wait a bit to ensure it's fully closed\n        await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    catch (error) {\n        console.log('Background: No existing offscreen document to close');\n    }\n    // Retry logic for offscreen document setup\n    let setupAttempts = 0;\n    const maxSetupAttempts = 3;\n    while (setupAttempts < maxSetupAttempts) {\n        try {\n            await setupOffscreenDocument();\n            break;\n        }\n        catch (error) {\n            setupAttempts++;\n            if (setupAttempts >= maxSetupAttempts) {\n                throw new Error('Failed to setup offscreen document after multiple attempts');\n            }\n            console.log(`Retrying offscreen document setup (attempt ${setupAttempts + 1})...`);\n            await new Promise(resolve => setTimeout(resolve, 1000 * setupAttempts));\n        }\n    }\n    return new Promise((resolve, reject) => {\n        chrome.runtime.sendMessage({\n            target: 'offscreen-auth',\n            action: action,\n            ...data\n        }, (response) => {\n            if (chrome.runtime.lastError) {\n                console.error('Chrome runtime error:', chrome.runtime.lastError);\n                reject(chrome.runtime.lastError);\n            }\n            else if (!response || typeof response !== 'object') {\n                console.error('Invalid response from offscreen document:', response);\n                reject(new Error('Invalid response from offscreen document'));\n            }\n            else if (!response.success) {\n                // Enhanced error handling for specific auth errors\n                const error = response.error || {};\n                const errorCode = error.code || 'unknown';\n                let errorMessage = error.message || 'Authentication failed';\n                // Provide user-friendly error messages\n                switch (errorCode) {\n                    case 'auth/invalid-credential':\n                        errorMessage = 'Invalid email or password. Please check your credentials and try again.';\n                        break;\n                    case 'auth/user-not-found':\n                        errorMessage = 'No account found with this email address. Please sign up first.';\n                        break;\n                    case 'auth/wrong-password':\n                        errorMessage = 'Incorrect password. Please try again.';\n                        break;\n                    case 'auth/email-already-in-use':\n                        errorMessage = 'This email is already registered. Please sign in instead.';\n                        break;\n                    case 'auth/weak-password':\n                        errorMessage = 'Password is too weak. Please use at least 6 characters.';\n                        break;\n                    case 'auth/network-request-failed':\n                        errorMessage = 'Network error. Please check your internet connection.';\n                        break;\n                    case 'auth/popup-blocked':\n                        errorMessage = 'Pop-up was blocked. Please allow pop-ups for this extension.';\n                        break;\n                    case 'auth/cancelled-popup-request':\n                        errorMessage = 'Sign-in was cancelled. Please try again.';\n                        break;\n                    case 'iframe-timeout':\n                        errorMessage = 'Authentication timed out. Please try again.';\n                        break;\n                    case 'iframe-not-found':\n                        errorMessage = 'Authentication system not ready. Please try again in a moment.';\n                        break;\n                }\n                reject({ code: errorCode, message: errorMessage });\n            }\n            else {\n                resolve(response);\n            }\n        });\n    });\n}\n// Periodically verify auth state is still valid\nasync function verifyAuthState() {\n    if (!currentUser)\n        return;\n    try {\n        console.log('Background: Verifying auth state...');\n        const result = await handleAuthAction('verifyAuthState', {});\n        if (!result.isValid) {\n            console.log('Background: Auth state is no longer valid, clearing...');\n            currentUser = null;\n            await chrome.storage.local.remove(['authUser', 'authTimestamp']);\n            // Notify all tabs\n            chrome.tabs.query({}, (tabs) => {\n                tabs.forEach(tab => {\n                    if (tab.id) {\n                        chrome.tabs.sendMessage(tab.id, {\n                            action: 'authStateChanged',\n                            user: null\n                        }).catch(() => { });\n                    }\n                });\n            });\n        }\n    }\n    catch (error) {\n        console.error('Background: Error verifying auth state:', error);\n    }\n}\n// Set up periodic auth verification (every 5 minutes)\nsetInterval(verifyAuthState, 5 * 60 * 1000);\n// Handle extension icon clicks - always show verse overlay first\nchrome.action.onClicked.addListener((tab) => {\n    if (!tab.id || !tab.url) {\n        console.log('Background: No tab ID or URL available');\n        return;\n    }\n    // For restricted URLs and OAuth pages, open a new tab with a regular website\n    const skipSites = [\n        \"chrome://\",\n        \"chrome-extension://\",\n        \"moz-extension://\",\n        \"extensions\",\n        \"about:\",\n        \"file://\",\n        // OAuth and authentication URLs\n        \"accounts.google.com\",\n        \"oauth2.googleapis.com\",\n        \"auth.firebase.com\",\n        \"identitytoolkit.googleapis.com\",\n        \"securetoken.googleapis.com\",\n        // Microsoft Edge identity redirect\n        \"login.microsoftonline.com\",\n        \"login.live.com\"\n    ];\n    if (skipSites.some(site => tab.url.includes(site))) {\n        console.log('Background: Cannot inject into restricted/auth URL, opening new tab:', tab.url);\n        chrome.tabs.create({ url: 'https://www.google.com' }, (newTab) => {\n            if (newTab.id) {\n                // Wait a moment for the tab to load, then inject verse app\n                setTimeout(() => {\n                    // Clear storage first\n                    chrome.storage.local.remove(['verseShownDate'], () => {\n                        // Then inject the verse app\n                        chrome.scripting.executeScript({\n                            target: { tabId: newTab.id },\n                            files: ['verse-app.js']\n                        }).then(() => {\n                            console.log('Background: Verse app injected in new tab');\n                        }).catch((error) => {\n                            console.error('Background: Error injecting verse app in new tab:', error);\n                        });\n                    });\n                }, 1500);\n            }\n        });\n        return;\n    }\n    try {\n        // First clear the storage to force show\n        chrome.storage.local.remove(['verseShownDate'], () => {\n            // Then inject the verse app directly\n            chrome.scripting.executeScript({\n                target: { tabId: tab.id },\n                files: ['verse-app.js']\n            }).then(() => {\n                console.log('Background: Verse app injected via icon click');\n            }).catch((error) => {\n                console.error('Background: Error injecting verse app:', error);\n            });\n        });\n    }\n    catch (error) {\n        console.error('Background: Failed to execute script on tab:', tab.url, error);\n    }\n});\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('Daily Flame extension installed');\n    // Check for stored auth state on extension startup\n    getStoredAuthState().then(storedUser => {\n        if (storedUser) {\n            currentUser = storedUser;\n            console.log('Background: Restored auth state from storage');\n        }\n    });\n    // Pre-warm offscreen document for faster first sign-in\n    console.log('Background: Pre-warming offscreen document');\n    setupOffscreenDocument().then(() => {\n        console.log('Background: Offscreen document ready');\n    }).catch(error => {\n        console.error('Background: Failed to pre-warm offscreen document:', error);\n    });\n});\n// Also check auth state when extension starts\ngetStoredAuthState().then(storedUser => {\n    if (storedUser) {\n        currentUser = storedUser;\n        console.log('Background: Restored auth state on startup');\n    }\n});\n// Pre-warm offscreen document on startup (not just install)\nsetupOffscreenDocument().catch(() => {\n    // Ignore errors on startup pre-warm\n});\nconsole.log('Background script loaded successfully');\n"],"names":[],"sourceRoot":""}